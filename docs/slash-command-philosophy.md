# Slash Command 架构哲学

## 核心问题

为什么不用程序化检测AI味和假细节？

## 两种架构对比

### ❌ 程序化检测架构（之前的错误）

```
用户输入 → 正则匹配 → 检测到"值得注意的是" → 标记为AI味
```

**问题**：
1. **机械匹配**：只能识别已知的pattern，无法灵活判断
2. **上下文盲**：同样的词在不同语境下含义不同，程序无法理解
3. **维护成本高**：需要不断更新规则库
4. **容易误判**：把正常的表达也标记为AI味

**示例**：
```typescript
// hard code的规则
const AI_TASTE_PATTERNS = [
  { pattern: /值得注意的是/, severity: 'high' }
];

// 机械匹配
if (text.includes('值得注意的是')) {
  return '检测到AI味';
}
```

这种方式就像用**字典**查单词，只能识别已知的，无法理解含义。

---

### ✅ AI判断架构（正确的slash command方式）

```
用户输入 → AI读取标准 → 理解上下文 → 灵活判断 → 生成反馈
```

**优势**：
1. **灵活判断**：AI可以理解上下文，不是机械匹配
2. **动态适应**：标准在markdown中，易于修改和扩展
3. **无需维护规则库**：AI自己理解原则
4. **减少误判**：AI可以根据语境判断

**示例**：

markdown模板：
```markdown
## AI味识别

**过渡套话**：
- 例子："值得注意的是"
- 为什么是AI味：学术腔，真人说话更直接
- 判断方法：看上下文是否必要
- 建议："我发现"、"说实话"
```

AI执行：
```
AI读取标准 → 理解"学术腔"的概念 
→ 看具体上下文 
→ 判断："值得注意的是，他的代码很优雅" 
→ 确实有AI味（学术腔，可以更直接）
→ 生成建议："改为'我发现，他的代码很优雅'"
```

这种方式就像**人类审稿**，理解含义、考虑上下文、灵活判断。

---

## 为什么AI判断更好？

### 1. 理解上下文

**程序化检测**：
```
文本："经过多次测试表明效果很好"
检测：匹配到"多次测试表明" → 标记为假细节
```

**AI判断**：
```
文本："经过多次测试表明效果很好"
AI判断：
- "多次"是几次？没说
- "效果很好"太抽象，没有具体数据
- 这确实是假细节
- 建议：改为"测了30个场景，26个成功，准确率87%"
```

AI不仅能发现问题，还能**理解为什么**有问题，给出**具体的**修改建议。

### 2. 灵活适应

**程序化检测**：
```typescript
// 硬编码规则
if (text.includes('显著提升')) {
  return '抽象表达，需要具体数字';
}
```

无法处理：
- "显著提升了50%" → 这里有具体数字，应该通过
- "销量显著提升" → 在财报中，这是专业术语，可能合适

**AI判断**：
```
标准：书面语"显著提升"通常太抽象，需要具体数字

AI灵活应用：
- "显著提升了50%" → 有数字，通过
- "财报中销量显著提升" → 财报用语，可以接受
- "效率显著提升" → 没数字，确实有问题
```

### 3. 无需维护规则库

**程序化检测**：
```typescript
// 需要不断更新
const AI_TASTE_PATTERNS = [
  { pattern: /值得注意的是/ },
  { pattern: /需要指出的是/ },
  { pattern: /不得不说/ },
  // ... 200+ 个规则
  // 还要继续添加新的...
];
```

每发现一个新的AI味pattern，就要更新代码。

**AI判断**：
```markdown
## 过渡套话

常见特征：学术腔、过于正式

例子（不限于）：
- "值得注意的是"
- "需要指出的是"

判断原则：
- 真人说话是否会用这个词？
- 能否用更直接的表达？
```

AI理解**原则**，不需要记住所有例子。新出现的AI味也能识别。

### 4. 减少误判

**程序化检测**：
```
文本："基于React的组件库"
检测：匹配到"基于...的" → 标记为AI味
误判！这是技术术语，合理的
```

**AI判断**：
```
文本："基于React的组件库"
AI判断：
- 这是技术领域的标准表达
- 不是AI套话
- 通过
```

---

## 架构设计

### 三层分离

```
┌─────────────────────────────────────┐
│   Markdown 指令层                    │
│   - 检查标准（自然语言）              │
│   - 判断原则                          │
│   - 示例说明                          │
└─────────────────────────────────────┘
              ↓
┌─────────────────────────────────────┐
│   AI 执行层                          │
│   - 读取并理解标准                    │
│   - 根据上下文灵活判断                │
│   - 生成个性化反馈                    │
└─────────────────────────────────────┘
              ↓
┌─────────────────────────────────────┐
│   工具层 (TypeScript)                │
│   - 文件读写                         │
│   - 状态管理                         │
│   - 简单计算                         │
└─────────────────────────────────────┘
```

### 职责划分

**Markdown层**：
- 定义"什么是好的"（标准）
- 解释"为什么"（原则）
- 举例说明（示例）

**AI层**：
- 理解标准和原则
- 分析具体内容
- 灵活判断
- 生成反馈

**TypeScript层**：
- 只做数据和状态
- 不做判断和检测
- 极简工具函数

---

## 实际应用

### 场景1：检查AI味

**用户**：`/authentic`

**AI执行**：
1. 读取 `templates/commands/authentic.md`
2. 理解AI味的判断标准
3. 通读用户的文章
4. 根据标准找出问题
5. 对每个问题：
   - 引用原文
   - 说明为什么有问题（基于原则）
   - 给出修改建议（个性化）
6. 生成报告

**优势**：
- AI可以理解整篇文章的语境
- 可以发现新的AI味pattern（只要符合原则）
- 给出的建议是针对性的，不是模板化的

### 场景2：扩展素材

**用户**：`/extract "测了30个场景，准确率87%"`

**AI执行**：
1. 读取 `templates/commands/extract.md`
2. 理解提问原则：挖掘5W1H、感官细节、内心世界
3. 根据这条素材，生成针对性的问题：
   - "什么时候测的？"
   - "最让你印象深刻的是哪个场景？"
   - "看到87%时第一反应是什么？"
4. 检查用户写的内容是否真实

**优势**：
- 问题是针对具体素材生成的，不是模板化的
- AI可以根据用户的回答追问
- 检查标准灵活应用

---

## 为什么这样设计？

### 1. Slash Command的本质

Slash command不是**预设脚本**，而是**AI的指令手册**。

❌ 错误理解：
```
/write → 执行硬编码的对话流程
```

✅ 正确理解：
```
/write → AI读取指令 → 灵活执行 → 根据用户反馈调整
```

### 2. AI的优势

AI最大的优势是：
- **理解自然语言**
- **上下文推理**
- **灵活生成**

程序化检测浪费了这些优势，反而用AI最不擅长的方式（机械匹配）。

### 3. 可维护性

**程序化规则库**：
- 需要持续维护
- 每个新pattern都要写代码
- 容易过时

**自然语言标准**：
- 易于理解
- 易于修改
- AI自动适应

---

## 验收标准

一个正确的slash command系统应该：

- [ ] ✅ TypeScript只做文件读写、状态管理
- [ ] ✅ 没有任何正则匹配、检测规则
- [ ] ✅ 所有标准在markdown中用自然语言描述
- [ ] ✅ AI根据标准灵活判断，不是机械匹配
- [ ] ✅ AI可以处理未在示例中列出的case

---

## 总结

| | 程序化检测 | AI判断 |
|---|---|---|
| **方式** | 正则匹配 | 理解+推理 |
| **上下文** | 无法理解 | 完全理解 |
| **灵活性** | 机械匹配 | 灵活适应 |
| **维护** | 需要更新代码 | 修改markdown |
| **误判** | 容易误判 | 少误判 |
| **新pattern** | 无法识别 | 可以识别 |

**核心原则**：
> 让AI做AI擅长的事（理解、推理、判断），
> 让程序做程序擅长的事（存储、计算、读写）。

